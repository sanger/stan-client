/*! For license information please see 417.fae047d3.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[417],{"./node_modules/@xstate/react/dist/xstate-react.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{zl:()=>useMachine});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),use_sync_external_store_shim__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/use-sync-external-store/shim/index.js"),use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js"),xstate__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/xstate/dist/raise-6420fe44.esm.js");__webpack_require__("./node_modules/use-sync-external-store/shim/with-selector.js");const forEachActor=(actorRef,callback)=>{callback(actorRef);const children=actorRef.getSnapshot().children;children&&Object.values(children).forEach((child=>{forEachActor(child,callback)}))};function stopRootWithRehydration(actorRef){const persistedSnapshots=[];forEachActor(actorRef,(ref=>{persistedSnapshots.push([ref,ref.getSnapshot()]),ref.observers=new Set}));const systemSnapshot=actorRef.system.getSnapshot?.();actorRef.stop(),actorRef.system._snapshot=systemSnapshot,persistedSnapshots.forEach((([ref,snapshot])=>{ref._processingStatus=0,ref._snapshot=snapshot}))}function useIdleActorRef(logic,options){let[[currentConfig,actorRef],setCurrent]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)((()=>{const actorRef=(0,xstate__WEBPACK_IMPORTED_MODULE_4__.A)(logic,options);return[logic.config,actorRef]}));if(logic.config!==currentConfig){const newActorRef=(0,xstate__WEBPACK_IMPORTED_MODULE_4__.A)(logic,{...options,snapshot:actorRef.getPersistedSnapshot({__unsafeAllowInlineActors:!0})});setCurrent([logic.config,newActorRef]),actorRef=newActorRef}return(0,use_isomorphic_layout_effect__WEBPACK_IMPORTED_MODULE_2__.A)((()=>{actorRef.logic.implementations=logic.implementations})),actorRef}function useMachine(machine,options={}){return function useActor(logic,options={}){const actorRef=useIdleActorRef(logic,options),getSnapshot=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((()=>actorRef.getSnapshot()),[actorRef]),subscribe=(0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((handleStoreChange=>{const{unsubscribe}=actorRef.subscribe(handleStoreChange);return unsubscribe}),[actorRef]),actorSnapshot=(0,use_sync_external_store_shim__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)(subscribe,getSnapshot,getSnapshot);return(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>(actorRef.start(),()=>{stopRootWithRehydration(actorRef)})),[actorRef]),[actorSnapshot,actorRef.send,actorRef]}(machine,options)}},"./node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});const __WEBPACK_DEFAULT_EXPORT__=__webpack_require__("./node_modules/react/index.js").useLayoutEffect},"./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js":(__unused_webpack_module,exports,__webpack_require__)=>{var e=__webpack_require__("./node_modules/react/index.js");var k="function"==typeof Object.is?Object.is:function h(a,b){return a===b&&(0!==a||1/a==1/b)||a!=a&&b!=b},l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return!k(a,d)}catch(f){return!0}}var u="undefined"==typeof window||void 0===window.document||void 0===window.document.createElement?function t(a,b){return b()}:function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];return n((function(){c.value=d,c.getSnapshot=b,r(c)&&g({inst:c})}),[a,d,b]),m((function(){return r(c)&&g({inst:c}),a((function(){r(c)&&g({inst:c})}))}),[a]),p(d),d};exports.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u},"./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js":(__unused_webpack_module,exports,__webpack_require__)=>{var h=__webpack_require__("./node_modules/react/index.js"),n=__webpack_require__("./node_modules/use-sync-external-store/shim/index.js");var q="function"==typeof Object.is?Object.is:function p(a,b){return a===b&&(0!==a||1/a==1/b)||a!=a&&b!=b},r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue},"./node_modules/use-sync-external-store/shim/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js")},"./node_modules/use-sync-external-store/shim/with-selector.js":(module,__unused_webpack_exports,__webpack_require__)=>{__webpack_require__("./node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js")},"./node_modules/xstate/actors/dist/xstate-actors.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Sx:()=>fromPromise});var _dist_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/xstate/dist/raise-6420fe44.esm.js");const XSTATE_PROMISE_RESOLVE="xstate.promise.resolve",XSTATE_PROMISE_REJECT="xstate.promise.reject";function fromPromise(promiseCreator){return{config:promiseCreator,transition:(state,event)=>{if("active"!==state.status)return state;switch(event.type){case XSTATE_PROMISE_RESOLVE:{const resolvedValue=event.data;return{...state,status:"done",output:resolvedValue,input:void 0}}case XSTATE_PROMISE_REJECT:return{...state,status:"error",error:event.data,input:void 0};case _dist_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.X:return{...state,status:"stopped",input:void 0};default:return state}},start:(state,{self,system})=>{if("active"!==state.status)return;Promise.resolve(promiseCreator({input:state.input,system,self})).then((response=>{"active"===self.getSnapshot().status&&system._relay(self,self,{type:XSTATE_PROMISE_RESOLVE,data:response})}),(errorData=>{"active"===self.getSnapshot().status&&system._relay(self,self,{type:XSTATE_PROMISE_REJECT,data:errorData})}))},getInitialSnapshot:(_,input)=>({status:"active",output:void 0,error:void 0,input}),getPersistedSnapshot:snapshot=>snapshot,restoreSnapshot:snapshot=>snapshot}}(function fromTransition(transition,initialContext){return{config:transition,transition:(snapshot,event,actorScope)=>({...snapshot,context:transition(snapshot.context,event,actorScope)}),getInitialSnapshot:(_,input)=>({status:"active",output:void 0,error:void 0,context:"function"==typeof initialContext?initialContext({input}):initialContext}),getPersistedSnapshot:snapshot=>snapshot,restoreSnapshot:snapshot=>snapshot}})((_=>{}),void 0)},"./node_modules/xstate/dist/log-f78f0918.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{a:()=>assign,e:()=>enqueueActions});var _raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/xstate/dist/raise-6420fe44.esm.js");function createSpawner(actorScope,{machine,context},event,spawnedChildren){return(src,options)=>{const actorRef=((src,options={})=>{const{systemId,input}=options;if("string"==typeof src){const logic=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(machine,src);if(!logic)throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);const actorRef=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(logic,{id:options.id,parent:actorScope.self,syncSnapshot:options.syncSnapshot,input:"function"==typeof input?input({context,event,self:actorScope.self}):input,src,systemId});return spawnedChildren[actorRef.id]=actorRef,actorRef}return(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(src,{id:options.id,parent:actorScope.self,syncSnapshot:options.syncSnapshot,input:options.input,src,systemId})})(src,options);return spawnedChildren[actorRef.id]=actorRef,actorScope.defer((()=>{actorRef._processingStatus!==_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.T.Stopped&&actorRef.start()})),actorRef}}function resolveAssign(actorScope,snapshot,actionArgs,actionParams,{assignment}){if(!snapshot.context)throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");const spawnedChildren={},assignArgs={context:snapshot.context,event:actionArgs.event,spawn:createSpawner(actorScope,snapshot,actionArgs.event,spawnedChildren),self:actorScope.self,system:actorScope.system};let partialUpdate={};if("function"==typeof assignment)partialUpdate=assignment(assignArgs,actionParams);else for(const key of Object.keys(assignment)){const propAssignment=assignment[key];partialUpdate[key]="function"==typeof propAssignment?propAssignment(assignArgs,actionParams):propAssignment}const updatedContext=Object.assign({},snapshot.context,partialUpdate);return[(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.U)(snapshot,{context:updatedContext,children:Object.keys(spawnedChildren).length?{...snapshot.children,...spawnedChildren}:snapshot.children})]}function assign(assignment){function assign(args,params){}return assign.type="xstate.assign",assign.assignment=assignment,assign.resolve=resolveAssign,assign}let SpecialTargets=function(SpecialTargets){return SpecialTargets.Parent="#_parent",SpecialTargets.Internal="#_internal",SpecialTargets}({});function resolveSendTo(actorScope,snapshot,args,actionParams,{to,event:eventOrExpr,id,delay},extra){const delaysMap=snapshot.machine.implementations.delays;if("string"==typeof eventOrExpr)throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: "${eventOrExpr}" }) instead`);const resolvedEvent="function"==typeof eventOrExpr?eventOrExpr(args,actionParams):eventOrExpr;let resolvedDelay;if("string"==typeof delay){const configDelay=delaysMap&&delaysMap[delay];resolvedDelay="function"==typeof configDelay?configDelay(args,actionParams):configDelay}else resolvedDelay="function"==typeof delay?delay(args,actionParams):delay;const resolvedTarget="function"==typeof to?to(args,actionParams):to;let targetActorRef;if("string"==typeof resolvedTarget){if(targetActorRef=resolvedTarget===SpecialTargets.Parent?actorScope.self._parent:resolvedTarget===SpecialTargets.Internal?actorScope.self:resolvedTarget.startsWith("#_")?snapshot.children[resolvedTarget.slice(2)]:extra.deferredActorIds?.includes(resolvedTarget)?resolvedTarget:snapshot.children[resolvedTarget],!targetActorRef)throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`)}else targetActorRef=resolvedTarget||actorScope.self;return[snapshot,{to:targetActorRef,event:resolvedEvent,id,delay:resolvedDelay}]}function retryResolveSendTo(_,snapshot,params){"string"==typeof params.to&&(params.to=snapshot.children[params.to])}function executeSendTo(actorScope,params){actorScope.defer((()=>{const{to,event,delay,id}=params;"number"!=typeof delay?actorScope.system._relay(actorScope.self,to,event.type===_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.V?(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.W)(actorScope.self.id,event.data):event):actorScope.system.scheduler.schedule(actorScope.self,to,event,delay,id)}))}function sendTo(to,eventOrExpr,options){function sendTo(args,params){}return sendTo.type="xsnapshot.sendTo",sendTo.to=to,sendTo.event=eventOrExpr,sendTo.id=options?.id,sendTo.delay=options?.delay,sendTo.resolve=resolveSendTo,sendTo.retryResolve=retryResolveSendTo,sendTo.execute=executeSendTo,sendTo}function resolveEnqueueActions(actorScope,snapshot,args,_actionParams,{collect}){const actions=[],enqueue=function enqueue(action){actions.push(action)};return enqueue.assign=(...args)=>{actions.push(assign(...args))},enqueue.cancel=(...args)=>{actions.push((0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.M)(...args))},enqueue.raise=(...args)=>{actions.push((0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.O)(...args))},enqueue.sendTo=(...args)=>{actions.push(sendTo(...args))},enqueue.spawnChild=(...args)=>{actions.push((0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.P)(...args))},enqueue.stopChild=(...args)=>{actions.push((0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.R)(...args))},collect({context:args.context,event:args.event,enqueue,check:guard=>(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(guard,snapshot.context,args.event,snapshot),self:actorScope.self,system:actorScope.system}),[snapshot,void 0,actions]}function enqueueActions(collect){function enqueueActions(args,params){}return enqueueActions.type="xstate.enqueueActions",enqueueActions.collect=collect,enqueueActions.resolve=resolveEnqueueActions,enqueueActions}},"./node_modules/xstate/dist/raise-6420fe44.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{function getDevTools(){const w=function getGlobal(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==__webpack_require__.g?__webpack_require__.g:void 0}();if(w.__xstate__)return w.__xstate__}__webpack_require__.d(__webpack_exports__,{$:()=>$$ACTOR_TYPE,A:()=>createActor,M:()=>cancel,N:()=>NULL_EVENT,O:()=>raise,P:()=>spawnChild,R:()=>stopChild,S:()=>STATE_DELIMITER,T:()=>ProcessingStatus,U:()=>cloneMachineSnapshot,V:()=>XSTATE_ERROR,W:()=>createErrorActorEvent,X:()=>XSTATE_STOP,a:()=>toTransitionConfigArray,b:()=>formatTransition,c:()=>createInvokeId,d:()=>formatInitialTransition,e:()=>evaluateGuard,f:()=>formatTransitions,g:()=>getDelayedTransitions,h:()=>getCandidates,i:()=>getAllStateNodes,j:()=>getStateNodes,k:()=>createMachineSnapshot,l:()=>isInFinalState,m:()=>mapValues,n:()=>macrostep,o:()=>transitionNode,p:()=>resolveActionsAndContext,q:()=>createInitEvent,r:()=>resolveStateValue,s:()=>microstep,t:()=>toArray,u:()=>getInitialStateNodes,v:()=>toStatePath,w:()=>isStateId,x:()=>getStateNodeByPath,y:()=>getPersistedSnapshot,z:()=>resolveReferencedActor});const devToolsAdapter=service=>{if("undefined"==typeof window)return;const devTools=getDevTools();devTools&&devTools.register(service)};class Mailbox{constructor(_process){this._process=_process,this._active=!1,this._current=null,this._last=null}start(){this._active=!0,this.flush()}clear(){this._current&&(this._current.next=null,this._last=this._current)}enqueue(event){const enqueued={value:event,next:null};if(this._current)return this._last.next=enqueued,void(this._last=enqueued);this._current=enqueued,this._last=enqueued,this._active&&this.flush()}flush(){for(;this._current;){const consumed=this._current;this._process(consumed.value),this._current=consumed.next}this._last=null}}const STATE_DELIMITER=".",TARGETLESS_KEY="",NULL_EVENT="",WILDCARD="*",XSTATE_INIT="xstate.init",XSTATE_ERROR="xstate.error",XSTATE_STOP="xstate.stop";function createDoneStateEvent(id,output){return{type:`xstate.done.state.${id}`,output}}function createErrorActorEvent(id,error){return{type:`xstate.error.actor.${id}`,error}}function createInitEvent(input){return{type:XSTATE_INIT,input}}function reportUnhandledError(err){setTimeout((()=>{throw err}))}const symbolObservable="function"==typeof Symbol&&Symbol.observable||"@@observable";function createScheduledEventId(actorRef,id){return`${actorRef.sessionId}.${id}`}let idCounter=0;function matchesState(parentStateId,childStateId){const parentStateValue=toStateValue(parentStateId),childStateValue=toStateValue(childStateId);return"string"==typeof childStateValue?"string"==typeof parentStateValue&&childStateValue===parentStateValue:"string"==typeof parentStateValue?parentStateValue in childStateValue:Object.keys(parentStateValue).every((key=>key in childStateValue&&matchesState(parentStateValue[key],childStateValue[key])))}function toStatePath(stateId){if(isArray(stateId))return stateId;let result=[],segment="";for(let i=0;i<stateId.length;i++){switch(stateId.charCodeAt(i)){case 92:segment+=stateId[i+1],i++;continue;case 46:result.push(segment),segment="";continue}segment+=stateId[i]}return result.push(segment),result}function toStateValue(stateValue){if(function isMachineSnapshot(value){return!!value&&"object"==typeof value&&"machine"in value&&"value"in value}(stateValue))return stateValue.value;if("string"!=typeof stateValue)return stateValue;return function pathToStateValue(statePath){if(1===statePath.length)return statePath[0];const value={};let marker=value;for(let i=0;i<statePath.length-1;i++)if(i===statePath.length-2)marker[statePath[i]]=statePath[i+1];else{const previous=marker;marker={},previous[statePath[i]]=marker}return value}(toStatePath(stateValue))}function mapValues(collection,iteratee){const result={},collectionKeys=Object.keys(collection);for(let i=0;i<collectionKeys.length;i++){const key=collectionKeys[i];result[key]=iteratee(collection[key],key,collection,i)}return result}function toArrayStrict(value){return isArray(value)?value:[value]}function toArray(value){return void 0===value?[]:toArrayStrict(value)}function resolveOutput(mapper,context,event,self){return"function"==typeof mapper?mapper({context,event,self}):mapper}function isArray(value){return Array.isArray(value)}function toTransitionConfigArray(configLike){return toArrayStrict(configLike).map((transitionLike=>void 0===transitionLike||"string"==typeof transitionLike?{target:transitionLike}:transitionLike))}function normalizeTarget(target){if(void 0!==target&&target!==TARGETLESS_KEY)return toArray(target)}function toObserver(nextHandler,errorHandler,completionHandler){const isObserver="object"==typeof nextHandler,self=isObserver?nextHandler:void 0;return{next:(isObserver?nextHandler.next:nextHandler)?.bind(self),error:(isObserver?nextHandler.error:errorHandler)?.bind(self),complete:(isObserver?nextHandler.complete:completionHandler)?.bind(self)}}function createInvokeId(stateNodeId,index){return`${index}.${stateNodeId}`}function resolveReferencedActor(machine,src){const match=src.match(/^xstate\.invoke\.(\d+)\.(.*)/);if(!match)return machine.implementations.actors[src];const[,indexStr,nodeId]=match,invokeConfig=machine.getStateNodeById(nodeId).config.invoke;return(Array.isArray(invokeConfig)?invokeConfig[indexStr]:invokeConfig).src}const $$ACTOR_TYPE=1;let ProcessingStatus=function(ProcessingStatus){return ProcessingStatus[ProcessingStatus.NotStarted=0]="NotStarted",ProcessingStatus[ProcessingStatus.Running=1]="Running",ProcessingStatus[ProcessingStatus.Stopped=2]="Stopped",ProcessingStatus}({});const defaultOptions={clock:{setTimeout:(fn,ms)=>setTimeout(fn,ms),clearTimeout:id=>clearTimeout(id)},logger:console.log.bind(console),devTools:!1};class Actor{constructor(logic,options){this.logic=logic,this._snapshot=void 0,this.clock=void 0,this.options=void 0,this.id=void 0,this.mailbox=new Mailbox(this._process.bind(this)),this.observers=new Set,this.logger=void 0,this._processingStatus=ProcessingStatus.NotStarted,this._parent=void 0,this._syncSnapshot=void 0,this.ref=void 0,this._actorScope=void 0,this._systemId=void 0,this.sessionId=void 0,this.system=void 0,this._doneEvent=void 0,this.src=void 0,this._deferred=[];const resolvedOptions={...defaultOptions,...options},{clock,logger,parent,syncSnapshot,id,systemId,inspect}=resolvedOptions;this.system=parent?parent.system:function createSystem(rootActor,options){const children=new Map,keyedActors=new Map,reverseKeyedActors=new WeakMap,inspectionObservers=new Set,timerMap={},clock=options.clock,scheduler={schedule:(source,target,event,delay,id=Math.random().toString(36).slice(2))=>{const scheduledEvent={source,target,event,delay,id,startedAt:Date.now()},scheduledEventId=createScheduledEventId(source,id);system._snapshot._scheduledEvents[scheduledEventId]=scheduledEvent;const timeout=clock.setTimeout((()=>{delete timerMap[scheduledEventId],delete system._snapshot._scheduledEvents[scheduledEventId],system._relay(source,target,event)}),delay);timerMap[scheduledEventId]=timeout},cancel:(source,id)=>{const scheduledEventId=createScheduledEventId(source,id),timeout=timerMap[scheduledEventId];delete timerMap[scheduledEventId],delete system._snapshot._scheduledEvents[scheduledEventId],clock.clearTimeout(timeout)},cancelAll:actorRef=>{for(const scheduledEventId in system._snapshot._scheduledEvents){const scheduledEvent=system._snapshot._scheduledEvents[scheduledEventId];scheduledEvent.source===actorRef&&scheduler.cancel(actorRef,scheduledEvent.id)}}},system={_snapshot:{_scheduledEvents:(options?.snapshot&&options.snapshot.scheduler)??{}},_bookId:()=>"x:"+idCounter++,_register:(sessionId,actorRef)=>(children.set(sessionId,actorRef),sessionId),_unregister:actorRef=>{children.delete(actorRef.sessionId);const systemId=reverseKeyedActors.get(actorRef);void 0!==systemId&&(keyedActors.delete(systemId),reverseKeyedActors.delete(actorRef))},get:systemId=>keyedActors.get(systemId),_set:(systemId,actorRef)=>{const existing=keyedActors.get(systemId);if(existing&&existing!==actorRef)throw new Error(`Actor with system ID '${systemId}' already exists.`);keyedActors.set(systemId,actorRef),reverseKeyedActors.set(actorRef,systemId)},inspect:observer=>{inspectionObservers.add(observer)},_sendInspectionEvent:event=>{if(!inspectionObservers.size)return;const resolvedInspectionEvent={...event,rootId:rootActor.sessionId};inspectionObservers.forEach((observer=>observer.next?.(resolvedInspectionEvent)))},_relay:(source,target,event)=>{system._sendInspectionEvent({type:"@xstate.event",sourceRef:source,actorRef:target,event}),target._send(event)},scheduler,getSnapshot:()=>({_scheduledEvents:{...system._snapshot._scheduledEvents}}),start:()=>{const scheduledEvents=system._snapshot._scheduledEvents;system._snapshot._scheduledEvents={};for(const scheduledId in scheduledEvents){const{source,target,event,delay,id}=scheduledEvents[scheduledId];scheduler.schedule(source,target,event,delay,id)}}};return system}(this,{clock}),inspect&&!parent&&this.system.inspect(toObserver(inspect)),this.sessionId=this.system._bookId(),this.id=id??this.sessionId,this.logger=logger,this.clock=clock,this._parent=parent,this._syncSnapshot=syncSnapshot,this.options=resolvedOptions,this.src=resolvedOptions.src??logic,this.ref=this,this._actorScope={self:this,id:this.id,sessionId:this.sessionId,logger:this.logger,defer:fn=>{this._deferred.push(fn)},system:this.system,stopChild:child=>{if(child._parent!==this)throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);child._stop()}},this.send=this.send.bind(this),this.system._sendInspectionEvent({type:"@xstate.actor",actorRef:this}),systemId&&(this._systemId=systemId,this.system._set(systemId,this)),this._initState(options?.snapshot??options?.state),systemId&&"active"!==this._snapshot.status&&this.system._unregister(this)}_initState(persistedState){try{this._snapshot=persistedState?this.logic.restoreSnapshot?this.logic.restoreSnapshot(persistedState,this._actorScope):persistedState:this.logic.getInitialSnapshot(this._actorScope,this.options?.input)}catch(err){this._snapshot={status:"error",output:void 0,error:err}}}update(snapshot,event){let deferredFn;for(this._snapshot=snapshot;deferredFn=this._deferred.shift();)try{deferredFn()}catch(err){this._deferred.length=0,this._snapshot={...snapshot,status:"error",error:err}}switch(this._snapshot.status){case"active":for(const observer of this.observers)try{observer.next?.(snapshot)}catch(err){reportUnhandledError(err)}break;case"done":for(const observer of this.observers)try{observer.next?.(snapshot)}catch(err){reportUnhandledError(err)}this._stopProcedure(),this._complete(),this._doneEvent=function createDoneActorEvent(invokeId,output){return{type:`xstate.done.actor.${invokeId}`,output}}(this.id,this._snapshot.output),this._parent&&this.system._relay(this,this._parent,this._doneEvent);break;case"error":this._error(this._snapshot.error)}this.system._sendInspectionEvent({type:"@xstate.snapshot",actorRef:this,event,snapshot})}subscribe(nextListenerOrObserver,errorListener,completeListener){const observer=toObserver(nextListenerOrObserver,errorListener,completeListener);if(this._processingStatus!==ProcessingStatus.Stopped)this.observers.add(observer);else switch(this._snapshot.status){case"done":try{observer.complete?.()}catch(err){reportUnhandledError(err)}break;case"error":{const err=this._snapshot.error;if(observer.error)try{observer.error(err)}catch(err){reportUnhandledError(err)}else reportUnhandledError(err);break}}return{unsubscribe:()=>{this.observers.delete(observer)}}}start(){if(this._processingStatus===ProcessingStatus.Running)return this;this._syncSnapshot&&this.subscribe({next:snapshot=>{"active"===snapshot.status&&this.system._relay(this,this._parent,{type:`xstate.snapshot.${this.id}`,snapshot})},error:()=>{}}),this.system._register(this.sessionId,this),this._systemId&&this.system._set(this._systemId,this),this._processingStatus=ProcessingStatus.Running;const initEvent=createInitEvent(this.options.input);this.system._sendInspectionEvent({type:"@xstate.event",sourceRef:this._parent,actorRef:this,event:initEvent});switch(this._snapshot.status){case"done":return this.update(this._snapshot,initEvent),this;case"error":return this._error(this._snapshot.error),this}if(this._parent||this.system.start(),this.logic.start)try{this.logic.start(this._snapshot,this._actorScope)}catch(err){return this._snapshot={...this._snapshot,status:"error",error:err},this._error(err),this}return this.update(this._snapshot,initEvent),this.options.devTools&&this.attachDevTools(),this.mailbox.start(),this}_process(event){let nextState,caughtError;try{nextState=this.logic.transition(this._snapshot,event,this._actorScope)}catch(err){caughtError={err}}if(caughtError){const{err}=caughtError;return this._snapshot={...this._snapshot,status:"error",error:err},void this._error(err)}this.update(nextState,event),event.type===XSTATE_STOP&&(this._stopProcedure(),this._complete())}_stop(){return this._processingStatus===ProcessingStatus.Stopped?this:(this.mailbox.clear(),this._processingStatus===ProcessingStatus.NotStarted?(this._processingStatus=ProcessingStatus.Stopped,this):(this.mailbox.enqueue({type:XSTATE_STOP}),this))}stop(){if(this._parent)throw new Error("A non-root actor cannot be stopped directly.");return this._stop()}_complete(){for(const observer of this.observers)try{observer.complete?.()}catch(err){reportUnhandledError(err)}this.observers.clear()}_reportError(err){if(!this.observers.size)return void(this._parent||reportUnhandledError(err));let reportError=!1;for(const observer of this.observers){const errorListener=observer.error;reportError||=!errorListener;try{errorListener?.(err)}catch(err2){reportUnhandledError(err2)}}this.observers.clear(),reportError&&reportUnhandledError(err)}_error(err){this._stopProcedure(),this._reportError(err),this._parent&&this.system._relay(this,this._parent,createErrorActorEvent(this.id,err))}_stopProcedure(){return this._processingStatus!==ProcessingStatus.Running||(this.system.scheduler.cancelAll(this),this.mailbox.clear(),this.mailbox=new Mailbox(this._process.bind(this)),this._processingStatus=ProcessingStatus.Stopped,this.system._unregister(this)),this}_send(event){this._processingStatus!==ProcessingStatus.Stopped&&this.mailbox.enqueue(event)}send(event){this.system._relay(void 0,this,event)}attachDevTools(){const{devTools}=this.options;if(devTools){("function"==typeof devTools?devTools:devToolsAdapter)(this)}}toJSON(){return{xstate$$type:$$ACTOR_TYPE,id:this.id}}getPersistedSnapshot(options){return this.logic.getPersistedSnapshot(this._snapshot,options)}[symbolObservable](){return this}getSnapshot(){return this._snapshot}}function createActor(logic,...[options]){return new Actor(logic,options)}function resolveCancel(_,snapshot,actionArgs,actionParams,{sendId}){return[snapshot,"function"==typeof sendId?sendId(actionArgs,actionParams):sendId]}function executeCancel(actorScope,resolvedSendId){actorScope.defer((()=>{actorScope.system.scheduler.cancel(actorScope.self,resolvedSendId)}))}function cancel(sendId){function cancel(args,params){}return cancel.type="xstate.cancel",cancel.sendId=sendId,cancel.resolve=resolveCancel,cancel.execute=executeCancel,cancel}function resolveSpawn(actorScope,snapshot,actionArgs,_actionParams,{id,systemId,src,input,syncSnapshot}){const logic="string"==typeof src?resolveReferencedActor(snapshot.machine,src):src,resolvedId="function"==typeof id?id(actionArgs):id;let actorRef;return logic&&(actorRef=createActor(logic,{id:resolvedId,src,parent:actorScope.self,syncSnapshot,systemId,input:"function"==typeof input?input({context:snapshot.context,event:actionArgs.event,self:actorScope.self}):input})),[cloneMachineSnapshot(snapshot,{children:{...snapshot.children,[resolvedId]:actorRef}}),{id,actorRef}]}function executeSpawn(actorScope,{id,actorRef}){actorRef&&actorScope.defer((()=>{actorRef._processingStatus!==ProcessingStatus.Stopped&&actorRef.start()}))}function spawnChild(...[src,{id,systemId,input,syncSnapshot=!1}={}]){function spawnChild(args,params){}return spawnChild.type="snapshot.spawnChild",spawnChild.id=id,spawnChild.systemId=systemId,spawnChild.src=src,spawnChild.input=input,spawnChild.syncSnapshot=syncSnapshot,spawnChild.resolve=resolveSpawn,spawnChild.execute=executeSpawn,spawnChild}function resolveStop(_,snapshot,args,actionParams,{actorRef}){const actorRefOrString="function"==typeof actorRef?actorRef(args,actionParams):actorRef,resolvedActorRef="string"==typeof actorRefOrString?snapshot.children[actorRefOrString]:actorRefOrString;let children=snapshot.children;return resolvedActorRef&&(children={...children},delete children[resolvedActorRef.id]),[cloneMachineSnapshot(snapshot,{children}),resolvedActorRef]}function executeStop(actorScope,actorRef){actorRef&&(actorScope.system._unregister(actorRef),actorRef._processingStatus===ProcessingStatus.Running?actorScope.defer((()=>{actorScope.stopChild(actorRef)})):actorScope.stopChild(actorRef))}function stopChild(actorRef){function stop(args,params){}return stop.type="xstate.stopChild",stop.actorRef=actorRef,stop.resolve=resolveStop,stop.execute=executeStop,stop}function evaluateGuard(guard,context,event,snapshot){const{machine}=snapshot,isInline="function"==typeof guard,resolved=isInline?guard:machine.implementations.guards["string"==typeof guard?guard:guard.type];if(!isInline&&!resolved)throw new Error(`Guard '${"string"==typeof guard?guard:guard.type}' is not implemented.'.`);if("function"!=typeof resolved)return evaluateGuard(resolved,context,event,snapshot);const guardArgs={context,event},guardParams=isInline||"string"==typeof guard?void 0:"params"in guard?"function"==typeof guard.params?guard.params({context,event}):guard.params:void 0;if(!("check"in resolved))return resolved(guardArgs,guardParams);return resolved.check(snapshot,guardArgs,resolved)}const isAtomicStateNode=stateNode=>"atomic"===stateNode.type||"final"===stateNode.type;function getChildren(stateNode){return Object.values(stateNode.states).filter((sn=>"history"!==sn.type))}function getProperAncestors(stateNode,toStateNode){const ancestors=[];if(toStateNode===stateNode)return ancestors;let m=stateNode.parent;for(;m&&m!==toStateNode;)ancestors.push(m),m=m.parent;return ancestors}function getAllStateNodes(stateNodes){const nodeSet=new Set(stateNodes),adjList=getAdjList(nodeSet);for(const s of nodeSet)if("compound"!==s.type||adjList.get(s)&&adjList.get(s).length){if("parallel"===s.type)for(const child of getChildren(s))if("history"!==child.type&&!nodeSet.has(child)){const initialStates=getInitialStateNodesWithTheirAncestors(child);for(const initialStateNode of initialStates)nodeSet.add(initialStateNode)}}else getInitialStateNodesWithTheirAncestors(s).forEach((sn=>nodeSet.add(sn)));for(const s of nodeSet){let m=s.parent;for(;m;)nodeSet.add(m),m=m.parent}return nodeSet}function getValueFromAdj(baseNode,adjList){const childStateNodes=adjList.get(baseNode);if(!childStateNodes)return{};if("compound"===baseNode.type){const childStateNode=childStateNodes[0];if(!childStateNode)return{};if(isAtomicStateNode(childStateNode))return childStateNode.key}const stateValue={};for(const childStateNode of childStateNodes)stateValue[childStateNode.key]=getValueFromAdj(childStateNode,adjList);return stateValue}function getAdjList(stateNodes){const adjList=new Map;for(const s of stateNodes)adjList.has(s)||adjList.set(s,[]),s.parent&&(adjList.has(s.parent)||adjList.set(s.parent,[]),adjList.get(s.parent).push(s));return adjList}function getStateValue(rootNode,stateNodes){return getValueFromAdj(rootNode,getAdjList(getAllStateNodes(stateNodes)))}function isInFinalState(stateNodeSet,stateNode){return"compound"===stateNode.type?getChildren(stateNode).some((s=>"final"===s.type&&stateNodeSet.has(s))):"parallel"===stateNode.type?getChildren(stateNode).every((sn=>isInFinalState(stateNodeSet,sn))):"final"===stateNode.type}const isStateId=str=>"#"===str[0];function getCandidates(stateNode,receivedEventType){return stateNode.transitions.get(receivedEventType)||[...stateNode.transitions.keys()].filter((eventDescriptor=>{if(eventDescriptor===WILDCARD)return!0;if(!eventDescriptor.endsWith(".*"))return!1;const partialEventTokens=eventDescriptor.split("."),eventTokens=receivedEventType.split(".");for(let tokenIndex=0;tokenIndex<partialEventTokens.length;tokenIndex++){const partialEventToken=partialEventTokens[tokenIndex],eventToken=eventTokens[tokenIndex];if("*"===partialEventToken){return tokenIndex===partialEventTokens.length-1}if(partialEventToken!==eventToken)return!1}return!0})).sort(((a,b)=>b.length-a.length)).flatMap((key=>stateNode.transitions.get(key)))}function getDelayedTransitions(stateNode){const afterConfig=stateNode.config.after;if(!afterConfig)return[];return Object.keys(afterConfig).flatMap(((delay,i)=>{const configTransition=afterConfig[delay],resolvedTransition="string"==typeof configTransition?{target:configTransition}:configTransition,resolvedDelay=Number.isNaN(+delay)?delay:+delay,eventType=((delay,i)=>{const afterEvent=function createAfterEvent(delayRef,id){return{type:`xstate.after.${delayRef}.${id}`}}(delay,stateNode.id),eventType=afterEvent.type;return stateNode.entry.push(raise(afterEvent,{id:eventType,delay})),stateNode.exit.push(cancel(eventType)),eventType})(resolvedDelay);return toArray(resolvedTransition).map((transition=>({...transition,event:eventType,delay:resolvedDelay})))})).map((delayedTransition=>{const{delay}=delayedTransition;return{...formatTransition(stateNode,delayedTransition.event,delayedTransition),delay}}))}function formatTransition(stateNode,descriptor,transitionConfig){const normalizedTarget=normalizeTarget(transitionConfig.target),reenter=transitionConfig.reenter??!1,target=function resolveTarget(stateNode,targets){if(void 0===targets)return;return targets.map((target=>{if("string"!=typeof target)return target;if(isStateId(target))return stateNode.machine.getStateNodeById(target);const isInternalTarget=target[0]===STATE_DELIMITER;if(isInternalTarget&&!stateNode.parent)return getStateNodeByPath(stateNode,target.slice(1));const resolvedTarget=isInternalTarget?stateNode.key+target:target;if(!stateNode.parent)throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);try{return getStateNodeByPath(stateNode.parent,resolvedTarget)}catch(err){throw new Error(`Invalid transition definition for state node '${stateNode.id}':\n${err.message}`)}}))}(stateNode,normalizedTarget),transition={...transitionConfig,actions:toArray(transitionConfig.actions),guard:transitionConfig.guard,target,source:stateNode,reenter,eventType:descriptor,toJSON:()=>({...transition,source:`#${stateNode.id}`,target:target?target.map((t=>`#${t.id}`)):void 0})};return transition}function formatTransitions(stateNode){const transitions=new Map;if(stateNode.config.on)for(const descriptor of Object.keys(stateNode.config.on)){if(descriptor===NULL_EVENT)throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');const transitionsConfig=stateNode.config.on[descriptor];transitions.set(descriptor,toTransitionConfigArray(transitionsConfig).map((t=>formatTransition(stateNode,descriptor,t))))}if(stateNode.config.onDone){const descriptor=`xstate.done.state.${stateNode.id}`;transitions.set(descriptor,toTransitionConfigArray(stateNode.config.onDone).map((t=>formatTransition(stateNode,descriptor,t))))}for(const invokeDef of stateNode.invoke){if(invokeDef.onDone){const descriptor=`xstate.done.actor.${invokeDef.id}`;transitions.set(descriptor,toTransitionConfigArray(invokeDef.onDone).map((t=>formatTransition(stateNode,descriptor,t))))}if(invokeDef.onError){const descriptor=`xstate.error.actor.${invokeDef.id}`;transitions.set(descriptor,toTransitionConfigArray(invokeDef.onError).map((t=>formatTransition(stateNode,descriptor,t))))}if(invokeDef.onSnapshot){const descriptor=`xstate.snapshot.${invokeDef.id}`;transitions.set(descriptor,toTransitionConfigArray(invokeDef.onSnapshot).map((t=>formatTransition(stateNode,descriptor,t))))}}for(const delayedTransition of stateNode.after){let existing=transitions.get(delayedTransition.eventType);existing||(existing=[],transitions.set(delayedTransition.eventType,existing)),existing.push(delayedTransition)}return transitions}function formatInitialTransition(stateNode,_target){const resolvedTarget="string"==typeof _target?stateNode.states[_target]:_target?stateNode.states[_target.target]:void 0;if(!resolvedTarget&&_target)throw new Error(`Initial state node "${_target}" not found on parent state node #${stateNode.id}`);const transition={source:stateNode,actions:_target&&"string"!=typeof _target?toArray(_target.actions):[],eventType:null,reenter:!1,target:resolvedTarget?[resolvedTarget]:[],toJSON:()=>({...transition,source:`#${stateNode.id}`,target:resolvedTarget?[`#${resolvedTarget.id}`]:[]})};return transition}function resolveHistoryDefaultTransition(stateNode){const normalizedTarget=normalizeTarget(stateNode.config.target);return normalizedTarget?{target:normalizedTarget.map((t=>"string"==typeof t?getStateNodeByPath(stateNode.parent,t):t))}:stateNode.parent.initial}function isHistoryNode(stateNode){return"history"===stateNode.type}function getInitialStateNodesWithTheirAncestors(stateNode){const states=getInitialStateNodes(stateNode);for(const initialState of states)for(const ancestor of getProperAncestors(initialState,stateNode))states.add(ancestor);return states}function getInitialStateNodes(stateNode){const set=new Set;return function iter(descStateNode){if(!set.has(descStateNode))if(set.add(descStateNode),"compound"===descStateNode.type)iter(descStateNode.initial.target[0]);else if("parallel"===descStateNode.type)for(const child of getChildren(descStateNode))iter(child)}(stateNode),set}function getStateNode(stateNode,stateKey){if(isStateId(stateKey))return stateNode.machine.getStateNodeById(stateKey);if(!stateNode.states)throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);const result=stateNode.states[stateKey];if(!result)throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);return result}function getStateNodeByPath(stateNode,statePath){if("string"==typeof statePath&&isStateId(statePath))try{return stateNode.machine.getStateNodeById(statePath)}catch(e){}const arrayStatePath=toStatePath(statePath).slice();let currentStateNode=stateNode;for(;arrayStatePath.length;){const key=arrayStatePath.shift();if(!key.length)break;currentStateNode=getStateNode(currentStateNode,key)}return currentStateNode}function getStateNodes(stateNode,stateValue){if("string"==typeof stateValue){const childStateNode=stateNode.states[stateValue];if(!childStateNode)throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);return[stateNode,childStateNode]}const childStateKeys=Object.keys(stateValue),childStateNodes=childStateKeys.map((subStateKey=>getStateNode(stateNode,subStateKey))).filter(Boolean);return[stateNode.machine.root,stateNode].concat(childStateNodes,childStateKeys.reduce(((allSubStateNodes,subStateKey)=>{const subStateNode=getStateNode(stateNode,subStateKey);if(!subStateNode)return allSubStateNodes;const subStateNodes=getStateNodes(subStateNode,stateValue[subStateKey]);return allSubStateNodes.concat(subStateNodes)}),[]))}function transitionNode(stateNode,stateValue,snapshot,event){return"string"==typeof stateValue?function transitionAtomicNode(stateNode,stateValue,snapshot,event){const next=getStateNode(stateNode,stateValue).next(snapshot,event);return next&&next.length?next:stateNode.next(snapshot,event)}(stateNode,stateValue,snapshot,event):1===Object.keys(stateValue).length?function transitionCompoundNode(stateNode,stateValue,snapshot,event){const subStateKeys=Object.keys(stateValue),next=transitionNode(getStateNode(stateNode,subStateKeys[0]),stateValue[subStateKeys[0]],snapshot,event);return next&&next.length?next:stateNode.next(snapshot,event)}(stateNode,stateValue,snapshot,event):function transitionParallelNode(stateNode,stateValue,snapshot,event){const allInnerTransitions=[];for(const subStateKey of Object.keys(stateValue)){const subStateValue=stateValue[subStateKey];if(!subStateValue)continue;const innerTransitions=transitionNode(getStateNode(stateNode,subStateKey),subStateValue,snapshot,event);innerTransitions&&allInnerTransitions.push(...innerTransitions)}return allInnerTransitions.length?allInnerTransitions:stateNode.next(snapshot,event)}(stateNode,stateValue,snapshot,event)}function getHistoryNodes(stateNode){return Object.keys(stateNode.states).map((key=>stateNode.states[key])).filter((sn=>"history"===sn.type))}function isDescendant(childStateNode,parentStateNode){let marker=childStateNode;for(;marker.parent&&marker.parent!==parentStateNode;)marker=marker.parent;return marker.parent===parentStateNode}function hasIntersection(s1,s2){const set1=new Set(s1),set2=new Set(s2);for(const item of set1)if(set2.has(item))return!0;for(const item of set2)if(set1.has(item))return!0;return!1}function removeConflictingTransitions(enabledTransitions,stateNodeSet,historyValue){const filteredTransitions=new Set;for(const t1 of enabledTransitions){let t1Preempted=!1;const transitionsToRemove=new Set;for(const t2 of filteredTransitions)if(hasIntersection(computeExitSet([t1],stateNodeSet,historyValue),computeExitSet([t2],stateNodeSet,historyValue))){if(!isDescendant(t1.source,t2.source)){t1Preempted=!0;break}transitionsToRemove.add(t2)}if(!t1Preempted){for(const t3 of transitionsToRemove)filteredTransitions.delete(t3);filteredTransitions.add(t1)}}return Array.from(filteredTransitions)}function getEffectiveTargetStates(transition,historyValue){if(!transition.target)return[];const targets=new Set;for(const targetNode of transition.target)if(isHistoryNode(targetNode))if(historyValue[targetNode.id])for(const node of historyValue[targetNode.id])targets.add(node);else for(const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode),historyValue))targets.add(node);else targets.add(targetNode);return[...targets]}function getTransitionDomain(transition,historyValue){const targetStates=getEffectiveTargetStates(transition,historyValue);if(!targetStates)return;if(!transition.reenter&&targetStates.every((target=>target===transition.source||isDescendant(target,transition.source))))return transition.source;const lca=function findLeastCommonAncestor(stateNodes){const[head,...tail]=stateNodes;for(const ancestor of getProperAncestors(head,void 0))if(tail.every((sn=>isDescendant(sn,ancestor))))return ancestor}(targetStates.concat(transition.source));return lca||(transition.reenter?void 0:transition.source.machine.root)}function computeExitSet(transitions,stateNodeSet,historyValue){const statesToExit=new Set;for(const t of transitions)if(t.target?.length){const domain=getTransitionDomain(t,historyValue);t.reenter&&t.source===domain&&statesToExit.add(domain);for(const stateNode of stateNodeSet)isDescendant(stateNode,domain)&&statesToExit.add(stateNode)}return[...statesToExit]}function microstep(transitions,currentSnapshot,actorScope,event,isInitial,internalQueue){if(!transitions.length)return currentSnapshot;const mutStateNodeSet=new Set(currentSnapshot._nodes);let historyValue=currentSnapshot.historyValue;const filteredTransitions=removeConflictingTransitions(transitions,mutStateNodeSet,historyValue);let nextState=currentSnapshot;isInitial||([nextState,historyValue]=function exitStates(currentSnapshot,event,actorScope,transitions,mutStateNodeSet,historyValue,internalQueue){let nextSnapshot=currentSnapshot;const statesToExit=computeExitSet(transitions,mutStateNodeSet,historyValue);let changedHistory;statesToExit.sort(((a,b)=>b.order-a.order));for(const exitStateNode of statesToExit)for(const historyNode of getHistoryNodes(exitStateNode)){let predicate;predicate="deep"===historyNode.history?sn=>isAtomicStateNode(sn)&&isDescendant(sn,exitStateNode):sn=>sn.parent===exitStateNode,changedHistory??={...historyValue},changedHistory[historyNode.id]=Array.from(mutStateNodeSet).filter(predicate)}for(const s of statesToExit)nextSnapshot=resolveActionsAndContext(nextSnapshot,event,actorScope,[...s.exit,...s.invoke.map((def=>stopChild(def.id)))],internalQueue),mutStateNodeSet.delete(s);return[nextSnapshot,changedHistory||historyValue]}(nextState,event,actorScope,filteredTransitions,mutStateNodeSet,historyValue,internalQueue)),nextState=resolveActionsAndContext(nextState,event,actorScope,filteredTransitions.flatMap((t=>t.actions)),internalQueue),nextState=function enterStates(currentSnapshot,event,actorScope,filteredTransitions,mutStateNodeSet,internalQueue,historyValue,isInitial){let nextSnapshot=currentSnapshot;const statesToEnter=new Set,statesForDefaultEntry=new Set;(function computeEntrySet(transitions,historyValue,statesForDefaultEntry,statesToEnter){for(const t of transitions){const domain=getTransitionDomain(t,historyValue);for(const s of t.target||[])isHistoryNode(s)||t.source===s&&t.source===domain&&!t.reenter||(statesToEnter.add(s),statesForDefaultEntry.add(s)),addDescendantStatesToEnter(s,historyValue,statesForDefaultEntry,statesToEnter);const targetStates=getEffectiveTargetStates(t,historyValue);for(const s of targetStates){const ancestors=getProperAncestors(s,domain);"parallel"===domain?.type&&ancestors.push(domain),addAncestorStatesToEnter(statesToEnter,historyValue,statesForDefaultEntry,ancestors,!t.source.parent&&t.reenter?void 0:domain)}}})(filteredTransitions,historyValue,statesForDefaultEntry,statesToEnter),isInitial&&statesForDefaultEntry.add(currentSnapshot.machine.root);const completedNodes=new Set;for(const stateNodeToEnter of[...statesToEnter].sort(((a,b)=>a.order-b.order))){mutStateNodeSet.add(stateNodeToEnter);const actions=[];actions.push(...stateNodeToEnter.entry);for(const invokeDef of stateNodeToEnter.invoke)actions.push(spawnChild(invokeDef.src,{...invokeDef,syncSnapshot:!!invokeDef.onSnapshot}));if(statesForDefaultEntry.has(stateNodeToEnter)){const initialActions=stateNodeToEnter.initial.actions;actions.push(...initialActions)}if(nextSnapshot=resolveActionsAndContext(nextSnapshot,event,actorScope,actions,internalQueue,stateNodeToEnter.invoke.map((invokeDef=>invokeDef.id))),"final"===stateNodeToEnter.type){const parent=stateNodeToEnter.parent;let ancestorMarker="parallel"===parent?.type?parent:parent?.parent,rootCompletionNode=ancestorMarker||stateNodeToEnter;for("compound"===parent?.type&&internalQueue.push(createDoneStateEvent(parent.id,stateNodeToEnter.output?resolveOutput(stateNodeToEnter.output,nextSnapshot.context,event,actorScope.self):void 0));"parallel"===ancestorMarker?.type&&!completedNodes.has(ancestorMarker)&&isInFinalState(mutStateNodeSet,ancestorMarker);)completedNodes.add(ancestorMarker),internalQueue.push(createDoneStateEvent(ancestorMarker.id)),rootCompletionNode=ancestorMarker,ancestorMarker=ancestorMarker.parent;if(ancestorMarker)continue;nextSnapshot=cloneMachineSnapshot(nextSnapshot,{status:"done",output:getMachineOutput(nextSnapshot,event,actorScope,nextSnapshot.machine.root,rootCompletionNode)})}}return nextSnapshot}(nextState,event,actorScope,filteredTransitions,mutStateNodeSet,internalQueue,historyValue,isInitial);const nextStateNodes=[...mutStateNodeSet];"done"===nextState.status&&(nextState=resolveActionsAndContext(nextState,event,actorScope,nextStateNodes.sort(((a,b)=>b.order-a.order)).flatMap((state=>state.exit)),internalQueue));try{return historyValue===currentSnapshot.historyValue&&function areStateNodeCollectionsEqual(prevStateNodes,nextStateNodeSet){if(prevStateNodes.length!==nextStateNodeSet.size)return!1;for(const node of prevStateNodes)if(!nextStateNodeSet.has(node))return!1;return!0}(currentSnapshot._nodes,mutStateNodeSet)?nextState:cloneMachineSnapshot(nextState,{_nodes:nextStateNodes,historyValue})}catch(e){throw e}}function getMachineOutput(snapshot,event,actorScope,rootNode,rootCompletionNode){if(!rootNode.output)return;const doneStateEvent=createDoneStateEvent(rootCompletionNode.id,rootCompletionNode.output&&rootCompletionNode.parent?resolveOutput(rootCompletionNode.output,snapshot.context,event,actorScope.self):void 0);return resolveOutput(rootNode.output,snapshot.context,doneStateEvent,actorScope.self)}function addDescendantStatesToEnter(stateNode,historyValue,statesForDefaultEntry,statesToEnter){if(isHistoryNode(stateNode))if(historyValue[stateNode.id]){const historyStateNodes=historyValue[stateNode.id];for(const s of historyStateNodes)statesToEnter.add(s),addDescendantStatesToEnter(s,historyValue,statesForDefaultEntry,statesToEnter);for(const s of historyStateNodes)addProperAncestorStatesToEnter(s,stateNode.parent,statesToEnter,historyValue,statesForDefaultEntry)}else{const historyDefaultTransition=resolveHistoryDefaultTransition(stateNode);for(const s of historyDefaultTransition.target)statesToEnter.add(s),historyDefaultTransition===stateNode.parent?.initial&&statesForDefaultEntry.add(stateNode.parent),addDescendantStatesToEnter(s,historyValue,statesForDefaultEntry,statesToEnter);for(const s of historyDefaultTransition.target)addProperAncestorStatesToEnter(s,stateNode.parent,statesToEnter,historyValue,statesForDefaultEntry)}else if("compound"===stateNode.type){const[initialState]=stateNode.initial.target;isHistoryNode(initialState)||(statesToEnter.add(initialState),statesForDefaultEntry.add(initialState)),addDescendantStatesToEnter(initialState,historyValue,statesForDefaultEntry,statesToEnter),addProperAncestorStatesToEnter(initialState,stateNode,statesToEnter,historyValue,statesForDefaultEntry)}else if("parallel"===stateNode.type)for(const child of getChildren(stateNode).filter((sn=>!isHistoryNode(sn))))[...statesToEnter].some((s=>isDescendant(s,child)))||(isHistoryNode(child)||(statesToEnter.add(child),statesForDefaultEntry.add(child)),addDescendantStatesToEnter(child,historyValue,statesForDefaultEntry,statesToEnter))}function addAncestorStatesToEnter(statesToEnter,historyValue,statesForDefaultEntry,ancestors,reentrancyDomain){for(const anc of ancestors)if(reentrancyDomain&&!isDescendant(anc,reentrancyDomain)||statesToEnter.add(anc),"parallel"===anc.type)for(const child of getChildren(anc).filter((sn=>!isHistoryNode(sn))))[...statesToEnter].some((s=>isDescendant(s,child)))||(statesToEnter.add(child),addDescendantStatesToEnter(child,historyValue,statesForDefaultEntry,statesToEnter))}function addProperAncestorStatesToEnter(stateNode,toStateNode,statesToEnter,historyValue,statesForDefaultEntry){addAncestorStatesToEnter(statesToEnter,historyValue,statesForDefaultEntry,getProperAncestors(stateNode,toStateNode))}function resolveAndExecuteActionsWithContext(currentSnapshot,event,actorScope,actions,extra,retries){const{machine}=currentSnapshot;let intermediateSnapshot=currentSnapshot;for(const action of actions){const isInline="function"==typeof action,resolvedAction=isInline?action:machine.implementations.actions["string"==typeof action?action:action.type];if(!resolvedAction)continue;const actionArgs={context:intermediateSnapshot.context,event,self:actorScope.self,system:actorScope.system},actionParams=isInline||"string"==typeof action?void 0:"params"in action?"function"==typeof action.params?action.params({context:intermediateSnapshot.context,event}):action.params:void 0;function executeAction(){actorScope.system._sendInspectionEvent({type:"@xstate.action",actorRef:actorScope.self,action:{type:"string"==typeof action?action:"object"==typeof action?action.type:action.name||"(anonymous)",params:actionParams}}),resolvedAction(actionArgs,actionParams)}if(!("resolve"in resolvedAction)){actorScope.self._processingStatus===ProcessingStatus.Running?executeAction():actorScope.defer((()=>{executeAction()}));continue}const builtinAction=resolvedAction,[nextState,params,actions]=builtinAction.resolve(actorScope,intermediateSnapshot,actionArgs,actionParams,resolvedAction,extra);intermediateSnapshot=nextState,"retryResolve"in builtinAction&&retries?.push([builtinAction,params]),"execute"in builtinAction&&(actorScope.self._processingStatus===ProcessingStatus.Running?builtinAction.execute(actorScope,params):actorScope.defer(builtinAction.execute.bind(null,actorScope,params))),actions&&(intermediateSnapshot=resolveAndExecuteActionsWithContext(intermediateSnapshot,event,actorScope,actions,extra,retries))}return intermediateSnapshot}function resolveActionsAndContext(currentSnapshot,event,actorScope,actions,internalQueue,deferredActorIds){const retries=deferredActorIds?[]:void 0,nextState=resolveAndExecuteActionsWithContext(currentSnapshot,event,actorScope,actions,{internalQueue,deferredActorIds},retries);return retries?.forEach((([builtinAction,params])=>{builtinAction.retryResolve(actorScope,nextState,params)})),nextState}function macrostep(snapshot,event,actorScope,internalQueue=[]){let nextSnapshot=snapshot;const microstates=[];function addMicrostate(microstate,event,transitions){actorScope.system._sendInspectionEvent({type:"@xstate.microstep",actorRef:actorScope.self,event,snapshot:microstate,_transitions:transitions}),microstates.push(microstate)}if(event.type===XSTATE_STOP)return nextSnapshot=cloneMachineSnapshot(stopChildren(nextSnapshot,event,actorScope),{status:"stopped"}),addMicrostate(nextSnapshot,event,[]),{snapshot:nextSnapshot,microstates};let nextEvent=event;if(nextEvent.type!==XSTATE_INIT){const currentEvent=nextEvent,isErr=function isErrorActorEvent(event){return event.type.startsWith("xstate.error.actor")}(currentEvent),transitions=selectTransitions(currentEvent,nextSnapshot);if(isErr&&!transitions.length)return nextSnapshot=cloneMachineSnapshot(snapshot,{status:"error",error:currentEvent.error}),addMicrostate(nextSnapshot,currentEvent,[]),{snapshot:nextSnapshot,microstates};nextSnapshot=microstep(transitions,snapshot,actorScope,nextEvent,!1,internalQueue),addMicrostate(nextSnapshot,currentEvent,transitions)}let shouldSelectEventlessTransitions=!0;for(;"active"===nextSnapshot.status;){let enabledTransitions=shouldSelectEventlessTransitions?selectEventlessTransitions(nextSnapshot,nextEvent):[];const previousState=enabledTransitions.length?nextSnapshot:void 0;if(!enabledTransitions.length){if(!internalQueue.length)break;nextEvent=internalQueue.shift(),enabledTransitions=selectTransitions(nextEvent,nextSnapshot)}nextSnapshot=microstep(enabledTransitions,nextSnapshot,actorScope,nextEvent,!1,internalQueue),shouldSelectEventlessTransitions=nextSnapshot!==previousState,addMicrostate(nextSnapshot,nextEvent,enabledTransitions)}return"active"!==nextSnapshot.status&&stopChildren(nextSnapshot,nextEvent,actorScope),{snapshot:nextSnapshot,microstates}}function stopChildren(nextState,event,actorScope){return resolveActionsAndContext(nextState,event,actorScope,Object.values(nextState.children).map((child=>stopChild(child))),[])}function selectTransitions(event,nextState){return nextState.machine.getTransitionData(nextState,event)}function selectEventlessTransitions(nextState,event){const enabledTransitionSet=new Set,atomicStates=nextState._nodes.filter(isAtomicStateNode);for(const stateNode of atomicStates)loop:for(const s of[stateNode].concat(getProperAncestors(stateNode,void 0)))if(s.always)for(const transition of s.always)if(void 0===transition.guard||evaluateGuard(transition.guard,nextState.context,event,nextState)){enabledTransitionSet.add(transition);break loop}return removeConflictingTransitions(Array.from(enabledTransitionSet),new Set(nextState._nodes),nextState.historyValue)}function resolveStateValue(rootNode,stateValue){return getStateValue(rootNode,[...getAllStateNodes(getStateNodes(rootNode,stateValue))])}const machineSnapshotMatches=function matches(testValue){return matchesState(testValue,this.value)},machineSnapshotHasTag=function hasTag(tag){return this.tags.has(tag)},machineSnapshotCan=function can(event){const transitionData=this.machine.getTransitionData(this,event);return!!transitionData?.length&&transitionData.some((t=>void 0!==t.target||t.actions.length))},machineSnapshotToJSON=function toJSON(){const{_nodes:nodes,tags,machine,getMeta,toJSON,can,hasTag,matches,...jsonValues}=this;return{...jsonValues,tags:Array.from(tags)}},machineSnapshotGetMeta=function getMeta(){return this._nodes.reduce(((acc,stateNode)=>(void 0!==stateNode.meta&&(acc[stateNode.id]=stateNode.meta),acc)),{})};function createMachineSnapshot(config,machine){return{status:config.status,output:config.output,error:config.error,machine,context:config.context,_nodes:config._nodes,value:getStateValue(machine.root,config._nodes),tags:new Set(config._nodes.flatMap((sn=>sn.tags))),children:config.children,historyValue:config.historyValue||{},matches:machineSnapshotMatches,hasTag:machineSnapshotHasTag,can:machineSnapshotCan,getMeta:machineSnapshotGetMeta,toJSON:machineSnapshotToJSON}}function cloneMachineSnapshot(snapshot,config={}){return createMachineSnapshot({...snapshot,...config},snapshot.machine)}function getPersistedSnapshot(snapshot,options){const{_nodes:nodes,tags,machine,children,context,can,hasTag,matches,getMeta,toJSON,...jsonValues}=snapshot,childrenJson={};for(const id in children){const child=children[id];childrenJson[id]={snapshot:child.getPersistedSnapshot(options),src:child.src,systemId:child._systemId,syncSnapshot:child._syncSnapshot}}return{...jsonValues,context:persistContext(context),children:childrenJson}}function persistContext(contextPart){let copy;for(const key in contextPart){const value=contextPart[key];if(value&&"object"==typeof value)if("sessionId"in value&&"send"in value&&"ref"in value)copy??=Array.isArray(contextPart)?contextPart.slice():{...contextPart},copy[key]={xstate$$type:$$ACTOR_TYPE,id:value.id};else{const result=persistContext(value);result!==value&&(copy??=Array.isArray(contextPart)?contextPart.slice():{...contextPart},copy[key]=result)}}return copy??contextPart}function resolveRaise(_,snapshot,args,actionParams,{event:eventOrExpr,id,delay},{internalQueue}){const delaysMap=snapshot.machine.implementations.delays;if("string"==typeof eventOrExpr)throw new Error(`Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`);const resolvedEvent="function"==typeof eventOrExpr?eventOrExpr(args,actionParams):eventOrExpr;let resolvedDelay;if("string"==typeof delay){const configDelay=delaysMap&&delaysMap[delay];resolvedDelay="function"==typeof configDelay?configDelay(args,actionParams):configDelay}else resolvedDelay="function"==typeof delay?delay(args,actionParams):delay;return"number"!=typeof resolvedDelay&&internalQueue.push(resolvedEvent),[snapshot,{event:resolvedEvent,id,delay:resolvedDelay}]}function executeRaise(actorScope,params){const{event,delay,id}=params;"number"!=typeof delay||actorScope.defer((()=>{const self=actorScope.self;actorScope.system.scheduler.schedule(self,self,event,delay,id)}))}function raise(eventOrExpr,options){function raise(args,params){}return raise.type="xstate.raise",raise.event=eventOrExpr,raise.id=options?.id,raise.delay=options?.delay,raise.resolve=resolveRaise,raise.execute=executeRaise,raise}},"./node_modules/xstate/dist/xstate.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Op:()=>createMachine});__webpack_require__("./node_modules/xstate/actors/dist/xstate-actors.esm.js");var _raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/xstate/dist/raise-6420fe44.esm.js"),_log_f78f0918_esm_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/xstate/dist/log-f78f0918.esm.js");const cache=new WeakMap;function memo(object,key,fn){let memoizedData=cache.get(object);return memoizedData?key in memoizedData||(memoizedData[key]=fn()):(memoizedData={[key]:fn()},cache.set(object,memoizedData)),memoizedData[key]}const EMPTY_OBJECT={},toSerializableAction=action=>"string"==typeof action?{type:action}:"function"==typeof action?"resolve"in action?{type:action.type}:{type:action.name}:action;class StateNode{constructor(config,options){if(this.config=config,this.key=void 0,this.id=void 0,this.type=void 0,this.path=void 0,this.states=void 0,this.history=void 0,this.entry=void 0,this.exit=void 0,this.parent=void 0,this.machine=void 0,this.meta=void 0,this.output=void 0,this.order=-1,this.description=void 0,this.tags=[],this.transitions=void 0,this.always=void 0,this.parent=options._parent,this.key=options._key,this.machine=options._machine,this.path=this.parent?this.parent.path.concat(this.key):[],this.id=this.config.id||[this.machine.id,...this.path].join(_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.S),this.type=this.config.type||(this.config.states&&Object.keys(this.config.states).length?"compound":this.config.history?"history":"atomic"),this.description=this.config.description,this.order=this.machine.idMap.size,this.machine.idMap.set(this.id,this),this.states=this.config.states?(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.config.states,((stateConfig,key)=>new StateNode(stateConfig,{_parent:this,_key:key,_machine:this.machine}))):EMPTY_OBJECT,"compound"===this.type&&!this.config.initial)throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);this.history=!0===this.config.history?"shallow":this.config.history||!1,this.entry=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.entry).slice(),this.exit=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.exit).slice(),this.meta=this.config.meta,this.output="final"!==this.type&&this.parent?void 0:this.config.output,this.tags=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(config.tags).slice()}_initialize(){this.transitions=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(this),this.config.always&&(this.always=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(this.config.always).map((t=>(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.N,t)))),Object.keys(this.states).forEach((key=>{this.states[key]._initialize()}))}get definition(){return{id:this.id,key:this.key,version:this.machine.version,type:this.type,initial:this.initial?{target:this.initial.target,source:this,actions:this.initial.actions.map(toSerializableAction),eventType:null,reenter:!1,toJSON:()=>({target:this.initial.target.map((t=>`#${t.id}`)),source:`#${this.id}`,actions:this.initial.actions.map(toSerializableAction),eventType:null})}:void 0,history:this.history,states:(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.states,(state=>state.definition)),on:this.on,transitions:[...this.transitions.values()].flat().map((t=>({...t,actions:t.actions.map(toSerializableAction)}))),entry:this.entry.map(toSerializableAction),exit:this.exit.map(toSerializableAction),meta:this.meta,order:this.order||-1,output:this.output,invoke:this.invoke,description:this.description,tags:this.tags}}toJSON(){return this.definition}get invoke(){return memo(this,"invoke",(()=>(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.invoke).map(((invokeConfig,i)=>{const{src,systemId}=invokeConfig,resolvedId=invokeConfig.id??(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id,i),resolvedSrc="string"==typeof src?src:`xstate.invoke.${(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id,i)}`;return{...invokeConfig,src:resolvedSrc,id:resolvedId,systemId,toJSON(){const{onDone,onError,...invokeDefValues}=invokeConfig;return{...invokeDefValues,type:"xstate.invoke",src:resolvedSrc,id:resolvedId}}}}))))}get on(){return memo(this,"on",(()=>[...this.transitions].flatMap((([descriptor,t])=>t.map((t=>[descriptor,t])))).reduce(((map,[descriptor,transition])=>(map[descriptor]=map[descriptor]||[],map[descriptor].push(transition),map)),{})))}get after(){return memo(this,"delayedTransitions",(()=>(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(this)))}get initial(){return memo(this,"initial",(()=>(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(this,this.config.initial)))}next(snapshot,event){const eventType=event.type,actions=[];let selectedTransition;const candidates=memo(this,`candidates-${eventType}`,(()=>(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.h)(this,eventType)));for(const candidate of candidates){const{guard}=candidate,resolvedContext=snapshot.context;let guardPassed=!1;try{guardPassed=!guard||(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.e)(guard,resolvedContext,event,snapshot)}catch(err){const guardType="string"==typeof guard?guard:"object"==typeof guard?guard.type:void 0;throw new Error(`Unable to evaluate guard ${guardType?`'${guardType}' `:""}in transition for event '${eventType}' in state node '${this.id}':\n${err.message}`)}if(guardPassed){actions.push(...candidate.actions),selectedTransition=candidate;break}}return selectedTransition?[selectedTransition]:void 0}get events(){return memo(this,"events",(()=>{const{states}=this,events=new Set(this.ownEvents);if(states)for(const stateId of Object.keys(states)){const state=states[stateId];if(state.states)for(const event of state.events)events.add(`${event}`)}return Array.from(events)}))}get ownEvents(){const events=new Set([...this.transitions.keys()].filter((descriptor=>this.transitions.get(descriptor).some((transition=>!(!transition.target&&!transition.actions.length&&!transition.reenter))))));return Array.from(events)}}class StateMachine{constructor(config,implementations){this.config=config,this.version=void 0,this.schemas=void 0,this.implementations=void 0,this.__xstatenode=!0,this.idMap=new Map,this.root=void 0,this.id=void 0,this.states=void 0,this.events=void 0,this.__TResolvedTypesMeta=void 0,this.id=config.id||"(machine)",this.implementations={actors:implementations?.actors??{},actions:implementations?.actions??{},delays:implementations?.delays??{},guards:implementations?.guards??{}},this.version=this.config.version,this.schemas=this.config.schemas,this.transition=this.transition.bind(this),this.getInitialSnapshot=this.getInitialSnapshot.bind(this),this.getPersistedSnapshot=this.getPersistedSnapshot.bind(this),this.restoreSnapshot=this.restoreSnapshot.bind(this),this.start=this.start.bind(this),this.root=new StateNode(config,{_key:this.id,_machine:this}),this.root._initialize(),this.states=this.root.states,this.events=this.root.events}provide(implementations){const{actions,guards,actors,delays}=this.implementations;return new StateMachine(this.config,{actions:{...actions,...implementations.actions},guards:{...guards,...implementations.guards},actors:{...actors,...implementations.actors},delays:{...delays,...implementations.delays}})}resolveState(config){const resolvedStateValue=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.r)(this.root,config.value),nodeSet=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root,resolvedStateValue));return(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({_nodes:[...nodeSet],context:config.context||{},children:{},status:(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.l)(nodeSet,this.root)?"done":config.status||"active",output:config.output,error:config.error,historyValue:config.historyValue},this)}transition(snapshot,event,actorScope){return(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot,event,actorScope).snapshot}microstep(snapshot,event,actorScope){return(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot,event,actorScope).microstates}getTransitionData(snapshot,event){return(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.o)(this.root,snapshot.value,snapshot,event)||[]}getPreInitialState(actorScope,initEvent,internalQueue){const{context}=this.config,preInitial=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({context:"function"!=typeof context&&context?context:{},_nodes:[this.root],children:{},status:"active"},this);if("function"==typeof context){const assignment=({spawn,event,self})=>context({spawn,input:event.input,self});return(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.p)(preInitial,initEvent,actorScope,[(0,_log_f78f0918_esm_js__WEBPACK_IMPORTED_MODULE_2__.a)(assignment)],internalQueue)}return preInitial}getInitialSnapshot(actorScope,input){const initEvent=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.q)(input),internalQueue=[],preInitialState=this.getPreInitialState(actorScope,initEvent,internalQueue),nextState=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.s)([{target:[...(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.u)(this.root)],source:this.root,reenter:!0,actions:[],eventType:null,toJSON:null}],preInitialState,actorScope,initEvent,!0,internalQueue),{snapshot:macroState}=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(nextState,initEvent,actorScope,internalQueue);return macroState}start(snapshot){Object.values(snapshot.children).forEach((child=>{"active"===child.getSnapshot().status&&child.start()}))}getStateNodeById(stateId){const fullPath=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.v)(stateId),relativePath=fullPath.slice(1),resolvedStateId=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.w)(fullPath[0])?fullPath[0].slice(1):fullPath[0],stateNode=this.idMap.get(resolvedStateId);if(!stateNode)throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);return(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.x)(stateNode,relativePath)}get definition(){return this.root.definition}toJSON(){return this.definition}getPersistedSnapshot(snapshot,options){return(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.y)(snapshot,options)}restoreSnapshot(snapshot,_actorScope){const children={},snapshotChildren=snapshot.children;Object.keys(snapshotChildren).forEach((actorId=>{const actorData=snapshotChildren[actorId],childState=actorData.snapshot,src=actorData.src,logic="string"==typeof src?(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.z)(this,src):src;if(!logic)return;const actorRef=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(logic,{id:actorId,parent:_actorScope.self,syncSnapshot:actorData.syncSnapshot,snapshot:childState,src,systemId:actorData.systemId});children[actorId]=actorRef}));const restoredSnapshot=(0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({...snapshot,children,_nodes:Array.from((0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root,snapshot.value)))},this);let seen=new Set;return function reviveContext(contextPart,children){if(!seen.has(contextPart)){seen.add(contextPart);for(let key in contextPart){const value=contextPart[key];if(value&&"object"==typeof value){if("xstate$$type"in value&&value.xstate$$type===_raise_6420fe44_esm_js__WEBPACK_IMPORTED_MODULE_1__.$){contextPart[key]=children[value.id];continue}reviveContext(value,children)}}}}(restoredSnapshot.context,children),restoredSnapshot}}function createMachine(config,implementations){return new StateMachine(config,implementations)}}}]);